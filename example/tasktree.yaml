runners:
  # Declare the default runner by name (tasks without run_in: use this runner)
  default: bash-strict

  # Default runner: bash with strict mode enabled
  bash-strict:
    shell: /bin/bash
    preamble: |
      set -euo pipefail

  # Docker runner: uses an Alpine image for containerised tasks
  alpine:
    dockerfile: ./Dockerfile
    context: .
    volumes:
      - ./output:/workspace/output

variables:
  # Value from environment variable with fallback default
  log_level: { env: LOG_LEVEL, default: "info" }
  # Value from a shell command evaluated at runtime
  build_number: { eval: "date +%Y%m%d" }
  # Value read directly from a file
  project_name: { read: project-name.txt }

imports:
  - file: tasks/utils.yaml
    as: utils

tasks:
  build:
    desc: Build outputs for a given type and target architecture
    args:
      - build_type:
          choices: ["debug", "release"]
          default: "debug"
      - target:
          type: str
          choices:
            - "x86"
            - "x86_64"
            - "arm"
            - "ppc"
          default: "x86_64"
    outputs: [build/**]
    cmd: |
      echo "Building {{ var.project_name }} (build #{{ var.build_number }}) for {{ arg.target }}..."
      mkdir -p build
      echo "code and stuff" > build/output-{{ arg.build_type }}-{{ arg.target }}.txt

  package:
    desc: Create an archive from multiple build variants
    deps:
      - build: ["debug", "x86"]
      - build: ["release"]
      - build: { build_type: "release", target: "ppc" }
    outputs: [archive.tar.gz]
    cmd: echo "making archive.tar.gz..."

  transform:
    desc: Transform source data (demonstrates named inputs/outputs and self-references)
    inputs:
      - source: source.txt  # Named input - reference with {{ self.inputs.source }}
    outputs:
      - result: processed/result.txt   # Named output - reference with {{ self.outputs.result }}
      - log: processed/transform.log   # Named output
    cmd: |
      mkdir -p processed
      echo "Processing {{ self.inputs.source }} [log_level={{ var.log_level }}]" > {{ self.outputs.log }}
      tr '[:lower:]' '[:upper:]' < {{ self.inputs.source }} > {{ self.outputs.result }}
      echo "Done" >> {{ self.outputs.log }}

  summarize:
    desc: Create a summary from transformed output (demonstrates dep.* template usage)
    deps: [transform]
    outputs: [processed/summary.txt]
    cmd: |
      {
        echo "=== Summary ==="
        echo "Result file: {{ dep.transform.outputs.result }}"
        echo "Characters: $(wc -c < {{ dep.transform.outputs.result }})"
      } > processed/summary.txt

  prepare-output:
    desc: Create the output directory on the host (required before Docker volume mounts)
    outputs:
      - dir_marker: output/.ready
    cmd: |
      mkdir -p output
      touch output/.ready

  docker-echo:
    desc: Run a command inside an Alpine Docker container
    deps: [prepare-output]
    run_in: alpine
    outputs: [output/docker-result.txt]
    cmd: |
      echo "Hello from Docker! Project={{ var.project_name }} Build={{ var.build_number }}" \
        > /workspace/output/docker-result.txt

  clean:
    desc: Remove all generated files
    cmd: |
      rm -rf build/ processed/ output/ archive.tar.gz reports/
      echo "Cleaned."
